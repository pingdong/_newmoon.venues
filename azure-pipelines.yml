# resources:
#   repositories:
#   - repository: templates
#     type: github
#     name: pingdong/azure.devops.templates
#     ref: refs/heads/master
#     endpoint: GitHub

variables:
- group: Build            # the name of the Library
- name: local#app.name
  value: Venues.FunctionApp

trigger:
  batch: true

pr:
  autoCancel: true   # Cancel previous build if check in multiple times

schedules:
- cron: '0 1 * * *' # Every day at 1 A.M.
  displayName: Nightly Build
  branches:
    include: 
    - master
  always: true      # Even no code change

stages:
# Quality
# TODO: Extract to QualityControl Template
- stage: QualityControl
  displayName: Quality Control
  jobs: 
  - job: StaticTesting
    displayName: Static Testing
    pool:
      vmImage: $(build#pool)
    workspace:
      clean: all 
    steps:
    - task: WhiteSource Bolt@20
      displayName: 'Run WhiteSource Bolt' 
      condition: |
        or 
        (
          eq(variables['Build.SourceBranch'], 'refs/heads/master'),
          eq(variables['Build.Reason'], 'PullRequest')
        )
        
  - job: UnitTesting
    displayName: Unit Testing
    pool:
      vmImage: $(build#pool)
    workspace:
      clean: all 
    variables:
    - group : Build.UnitTest
    - name  : local.unittesting#codecoveragehistory.directory
      value : '$(Build.ArtifactStagingDirectory)/history'
    - name  : local.unittesting#codecoveragehistory.directory
      value : ${{ lower(variables['local#app.name']) }}.$(Build.SourceBranchName)
    - name  : 'disable.coverage.autogenerate'
      value : 'true'
    steps:
    # Preparing
    - task: SonarCloudPrepare@1
      displayName: Preparing SonarCloud Analysis
      condition: |
        or 
        (
          eq(variables['Build.SourceBranch'], 'refs/heads/master'),
          eq(variables['Build.Reason'], 'PullRequest')
        )
      inputs:
        SonarCloud: SonarCloud
        organization: $(build.unittest#sonarcloud.organization)
        projectKey: ${{ lower(variables['local#app.name']) }}
        projectName: ${{ lower(variables['local#app.name']) }}
        extraProperties: |
          sonar.coverage.exclusions=**/*[Uu]nit[Tt]ests*/**/*
          sonar.cs.opencover.reportsPaths=$(Build.SourcesDirectory)/**/coverage.opencover.xml

    - task: UniversalPackages@0
      displayName: Getting Test Coverage History
      condition: eq(variables['Build.SourceBranch'], 'refs/heads/master')
      continueOnError: true
      inputs:
        command: download
        downloadDirectory: $(local.unittesting#codecoveragehistory.directory)
        feedsToUse: internal
        vstsFeed: $(build.unittest#coverage.history.feed)
        vstsFeedPackage: $(local.unittesting#codecoveragehistory.directory)
        vstsPackageVersion: '0.*'

    # Building
    - task: DotNetCoreCLI@2
      displayName: Building
      inputs:
        projects: '**/*.sln'    # The <ProjectGuid> element is not required if you build a solution (sln) containing that project.
                                # for SonarQube
        arguments: '--configuration $(build#configuration.release)'

    # Testing
    - task: DotNetCoreCLI@2
      displayName: Running Unit Testings
      inputs:
        command: test
        arguments: '--no-build --configuration $(build#configuration.release) /p:CollectCoverage=true /p:CoverletOutputFormat=opencover'
        publishTestResults: true
        projects: '**/*.[Uu]nit[Tt]ests/*.csproj'

    # Coverage Report
    - task: Palmmedia.reportgenerator.reportgenerator-build-release-task.reportgenerator@4
      displayName: Generating Test Coverage Report
      condition: ne(variables['Build.Reason'], 'PullRequest')
      inputs:
        reports: '$(Build.SourcesDirectory)/**/coverage.opencover.xml'
        targetdir: $(Build.SourcesDirectory)/Coverage
        reporttypes: Html;HtmlInline_AzurePipelines_Dark;Cobertura;Badges
        historydir: $(local.unittesting#codecoveragehistory.directory)

    - task: UniversalPackages@0
      displayName: Persisting Test Coverage History
      condition: eq(variables['Build.SourceBranch'], 'refs/heads/master')
      inputs:
        command: publish
        publishDirectory: $(local.unittesting#codecoveragehistory.directory)
        feedsToUsePublish: internal
        vstsFeedPublish: $(build.unittest#coverage.history.feed)
        vstsFeedPackagePublish: $(local.unittesting#codecoveragehistory.directory)
        versionOption: patch
        packagePublishDescription: Code Coverage History for repository $(Build.Repository.Name) on branch $(Build.SourceBranchName)
        verbosity: Information

    - task: PublishCodeCoverageResults@1
      displayName: Publishing Test Coverage Report
      condition: ne(variables['Build.Reason'], 'PullRequest')
      inputs:
        codeCoverageTool: Cobertura
        summaryFileLocation: $(Build.SourcesDirectory)/Coverage/Cobertura.xml
        reportDirectory: $(Build.SourcesDirectory)/Coverage

    # Code Analysis
    - task: SonarCloudAnalyze@1
      displayName: Running SonarCloud Code Analysis
      condition: |
        or 
        (
          eq(variables['Build.SourceBranch'], 'refs/heads/master'),
          eq(variables['Build.Reason'], 'PullRequest')
        )

    - task: SonarCloudPublish@1
      displayName: Publishing SonarCloud Analysis Result
      condition: |
        or 
        (
          eq(variables['Build.SourceBranch'], 'refs/heads/master'),
          eq(variables['Build.Reason'], 'PullRequest')
        )

# Build
# TODO: Extract to Build Template
- stage: Build
  displayName: Building
  dependsOn: QualityControl
  condition: |
    and
    (
      succeeded(),
      eq(variables['Build.SourceBranch'], 'refs/heads/master'),
      ne(variables['Build.Reason'], 'Schedule')
    )
  jobs:
  - job: Build
    displayName: Building
    pool:
      vmImage: $(build#pool)
    workspace:
      clean: all 
    variables:
    - group: Build
    steps:
    - task: DotNetCoreCLI@2
      displayName: Restoring dependencies
      inputs:
        command: restore
        projects: '**/*.csproj'
        arguments: '--configuration $(build#configuration.release)'

    - task: DotNetCoreCLI@2
      displayName: Building Artifact
      condition: succeeded()
      inputs:
        command: publish
        publishWebProjects: false
        projects: '**/$(local#app.name).csproj'
        arguments: '--no-restore --configuration $(build#configuration.release) --output $(Build.ArtifactStagingDirectory)'

    - task: PublishBuildArtifacts@1
      displayName: Publishing Artifact

  # - job: BuildDBMigrationScript
  #   displayName: Building Database Migration Script
  #   pool:
  #     vmImage: $(build#pool)
  #   workspace:
  #     clean: all 
  #   variables:
  #   - group: Build
  #   steps:
  #   - task: pekspro.pekspro-efcore-migration-script-generator.efcore-migration-script-generator.efcore-migration-script-generator-task@0
  #     displayName: 'Generate Migration Scripts'
  #     inputs:
  #       projectpath: src/infrastructure/Places.Infrastructure.csproj
  #       databasecontexts: DefaultDbContext
  #       targetfolder: '$(Build.ArtifactStagingDirectory)'
  #     condition: eq(variables['Build.SourceBranch'], 'refs/heads/master')
  #     env:
  #       ConnectionStrings__Default: $(Place-Db-ConnectionString)      

# Deployment
# TODO: Extract a FunctionApp Template
- stage: DeployToDev
  displayName: 'Deploy to the dev environment'
  dependsOn: Build
  condition: |
    and
    (
      succeeded(),
      eq(variables['Build.SourceBranch'], 'refs/heads/master'),
      ne(variables['Build.Reason'], 'Schedule')
    )
  variables:
  - group: Deploy
  - group: Deploy.Venue
  jobs:
  - deployment: Deploy
    pool:
      vmImage: $(build#pool)
    environment: dev
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            displayName: Getting Artifact
            artifact: drop

          - task: AzureWebApp@1
            displayName: Deploying
            inputs:
              azureSubscription: Azure
              appType: functionApp
              appName: $(deploy.venue#app.name)
              package: '$(Pipeline.Workspace)/drop/*.zip'


# TODO: Extract a FunctionApp Template with Slot swapping

          #TODO: Approval

          #TODO: Deploy to PROD with Slot
          # - task: AzureWebApp@1
          #   displayName: Deploying
          #   inputs:
          #     azureSubscription: $(deploy#azure.subscription)
          #     appType: functionApp
          #     appName: deploy.venue#app.name
          #     package: '$(Pipeline.Workspace)/drop/*.zip'
          #     #Uncomment the next lines to deploy to a deployment slot
          #     #deployToSlotOrASE: true
          #     #resourceGroupName: '<Resource Group Name>'
          #     #slotName: '<Slot name>'


          # - task: AzureAppServiceSettings@1
          #   displayName: 'Update web app settings'
          #   inputs:
          #     azureSubscription: 'Resource Manager - Tailspin - Space Game'
          #     appName: $(WebAppName)
          #     resourceGroupName: $(ResourceGroupName)
          #     appSettings: |
          #       [
          #         {
          #           "name": "AppSettings:LeaderboardFunctionUrl",
          #           "value": "http://$(LeaderboardAppName).azurewebsites.net/api/LeaderboardFunction",
          #           "slotSetting": false
          #         }
          #       ]

          #TODO: Swap slots
          # - task: AzureAppServiceManage@0
          #   inputs:
          #     azureSubscription: <Azure service connection>
          #     WebAppName: <name of the Function app>
          #     ResourceGroupName: <name of resource group>
          #     SourceSlot: staging
          #     SwapWithProduction: true
